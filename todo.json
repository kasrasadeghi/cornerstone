[
  {
    "category": "awaiting triage",
    "todos": [
    ]
  },
  {
    "category": "bb",
    "todos": [
      "figure out how to turn i1 into u64",
      "check that truncation happens from the same signedness to the same signedness",
      "check sign/zero extension semantics for ptrtoint of u64 vs i64",
      "llvm has a 'null' literal that we should support",
      "allow for more than 1 str-table with custom access keys",
      "int truncation and signed/zero extension",
      "global variables? immutable?"
    ]
  },  {
    "category": "backbone",
    "todos": [
      "don't include tests with include",
      "tree shaking for includes",
      "'string' and 'view' special forms",
      "consider removing Value from Expr choice after norm",
      "type aliases",
      "check: do files need to end in .bb?",
      "field-get and field-set accessors that turn into index/{load,store} or {insertvalue,extractvalue}",
      "type check marker",
      "consider making some things in the pass after normalization Name, not Value",
      "consider making Expr -> Tall Value to differentiate Tall",
      "test runner",
      "consider adding contracts (result and input predicates)",
      "make tester for backbone-test for implementation in any language",
      "global variables? immutable?"
    ]
  },
  {
    "category": "passes #backbone",
    "todos": [
      "passes should return the new texp with it's new proof",
      "type inference",
      "consider flipping Store operands",
      "consider flipping Index operands",
      "name scope resolution",
      "make blocks have lexical scope",
      "type check pass",
      "argument type check pass",
      "while loops",
      "string extraction pass"
    ]
  },
  {
    "category": "cornerstone",
    "todos": [
      "consider grammar normalization (extracting non-production children to gensym'd named productions)",
      "pass runner",
      "better error reporting via better printing",
      "README.md",
      "keyword resolution",
      "error out on parsing empty text from ()",
      "error out on wordless texps",
      "keyword + choice grammar error reporting",
      "add name deduplication for lookup in matcher",
      "proof algebra?",
      "environmentless pass conglomeration?",
      "pass ordering analysis?",
      "module system with decl/def deduplication",
      "include, include after pass, include after process",
      "source tracking between passes",
      "output file relative to input file path -flag",
      "texp pretty printer",
      "consider: subset grammars by having a unsubset pass"
    ]
  },
  {
    "category": "lib2",
    "todos": [
      "consider: matcher functions should free results of Matcher$ptr.is",
      "basic gen",
      "texp tabs representation"
    ]
  },
  {
    "category": "string #lib2",
    "todos": [
      "empty-append",
      "append-empty",
      "append null checks?"
    ]
  },
  {
    "category": "done",
    "todos": [
      "basic matcher #lib2",
      "basic parser #lib2",
      "include relative to current file #backbone",
      "int truncation and signed/zero extension #bb",
      "normalization #passes #backbone",
      "type expansion #passes #backbone",
      "more bitcasts #bb",
      "proof structure should be parallel with texp structure #cornerstone",
      "basic-append #string #lib2",
      "self-append #string #lib2",
      "basic grammar error reporting #cornerstone",
      "basic file and reader #lib2",
      "texp.push and .parenPrint #lib2",
      "change atoms to say /atom not /exact #cornerstone"
    ]
  }
]
